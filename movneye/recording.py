# Basic packages
import os
import time
import numpy as np
from sys import stderr
from datetime import datetime
# Parallel execution packages
from threading import Thread, Event
from multiprocessing import Process, Queue
# 1) DAVIS communication packages (for recording)
from pyaer import libcaer
from pyaer.davis import DAVIS
# 2) PTU communication packages (for movement)
from movneye.motion.ptu import PTU
from movneye.motion.ptu import find_ptuport, deg2pos, pos2deg
# 3) Image display package (for stimulation)
from movneye.utils.add2cv import get_multi_screen_geometry, adapt_img2screen, preprocess_image
from movneye.functional.store import store_json, update_json
from movneye.functional.read import read_json
import cv2


class RecordScene:
    """
    Class for live-recording (on a csv/txt file) the data generated by a neuromorphic camera (DAVIS sensor).
    All time parameters (such as dur_record or max_packet_interval) are considered to have millisecond units.
    Usage:
    myexp = RecordScene(set_all_recording_parameters)
    {loop:
        myexp.record_all(aps_file, dvs_file, imu_file)
    }
    myexp.close()
    """

    def __init__(self,
                 verbose: bool = True,
                 rec_file: str = None, file_extension: str = '.csv', what2rec: str = 'all',
                 duration_rec: float = 1000, timeout_rec: float = 5000, delay_rec: float = 0,
                 config_file: str = None, noise_filter: bool = False, roi: [[int, int], [int, int]] = None,
                 start_all_modules: bool = False, wait_valid_event: bool = True, reset_timestamps: bool = True,
                 max_packet_interval: float = 10, max_packet_size: int = 5000,
                 ):

        self.__davis_closed = False
        self.verbose = verbose

        # --------------------------------------------------------------------------------------------------------------
        # Recording info
        self.rec_file = rec_file
        self._duration_rec = duration_rec  # (ms) duration of a recording
        self._timeout_rec = timeout_rec  # (ms) time period to wait for recording thread to stream and log data
        if not self._timeout_rec > self._duration_rec:
            raise ValueError('Timeout for recording interruption must be greater than recording duration.')
        self._delay_rec = delay_rec if delay_rec is not None else 0  # (ms) time period to wait before recording begins
        self.file_extension = file_extension  # can be either '.csv' or '.txt'
        self.what2rec = what2rec
        # Sensor-specific info
        self._default_bias = True
        self._roi = roi  # [[int, int], [int, int]] = [top-left[x,y], bottom-right[x,y]]
        self._noise_filter = noise_filter
        self.reset_timestamps = reset_timestamps

        # Managing parallel executions
        self._exit_event = Event()     # useful for interrupting never-ending processes
        self._queue = Queue()          # useful for keeping track of the order in which the processes are executed
        self._order = dict()

        # ### Initialize the DAVIS object
        self.__init_davis(biases=read_json(config_file), start_all_modules=start_all_modules, wait_valid_event=wait_valid_event,
                          max_packet_interval=max_packet_interval, max_packet_size=max_packet_size)

        # --------------------------------------------------------------------------------------------------------------
        # ### Print info of recording
        if verbose:
            self.print_info()

    def __init_davis(self, biases: dict = None, start_all_modules: bool = False, wait_valid_event: bool = True,
                     max_packet_interval: float = 10, max_packet_size: int = 5000):
        self.davis = DAVIS(noise_filter=self._noise_filter)
        self.davis.send_default_config()
        # Set custom biases of the sensor (if a .json bias file is provided)
        self.davis_bias = biases
        # Set up USB host buffers for acquisition thread to minimize latency
        self.davis_communication_configuration(max_packet_interval=max_packet_interval, max_packet_size=max_packet_size)
        # Set up data exchange parameters to only enable the strictly-needed data flow
        self.davis_data_exchange_configuration(start_all_modules=start_all_modules, wait_valid_event=wait_valid_event)
        # Set the ROI filter (if ROI start/stop coordinates were provided)
        self.davis_roi_filter(roi=self._roi)

    @property
    def davis_name(self) -> str:
        return self.davis.device_string.split()[0]

    @property
    def davis_serial_number(self) -> str:
        return self.davis.device_serial_number

    @property
    def davis_device_id(self) -> int:
        return self.davis.device_id

    @property
    def davis_usb_bus_number(self) -> int:
        return self.davis.device_usb_bus_number

    @property
    def davis_usb_device_address(self) -> int:
        return self.davis.device_usb_device_address

    @property
    def davis_shape(self) -> (int, int):
        return self.davis.dvs_size_X, self.davis.dvs_size_Y

    @property
    def what2rec(self) -> str:
        return self._what2rec

    @what2rec.setter
    def what2rec(self, what2rec: str):
        self._what2rec = what2rec
        if what2rec not in ['aps', 'aps&imu', 'dvs', 'dvs&imu', 'all']:
            self._what2rec = 'all'

    @property
    def davis_enabled(self) -> bool:
        return all([self.davis_chip_enabled, self.davis_mux_enabled, self.davis_usb_enabled])

    @davis_enabled.setter
    def davis_enabled(self, enable: bool):
        self.davis_chip_enabled = enable
        self.davis_mux_enabled = enable
        self.davis_mux_timestamp_enabled = enable
        self.davis_usb_enabled = enable

    @property
    def davis_usb_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_USB,
                                     libcaer.DAVIS_CONFIG_USB_RUN)

    @davis_usb_enabled.setter
    def davis_usb_enabled(self, enable: bool):
        if not self.davis_usb_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_USB,
                                  libcaer.DAVIS_CONFIG_USB_RUN,
                                  enable)

    @property
    def davis_chip_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_MUX,
                                     libcaer.DAVIS_CONFIG_MUX_RUN_CHIP)

    @davis_chip_enabled.setter
    def davis_chip_enabled(self, enable: bool):
        if not self.davis_chip_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_MUX,
                                  libcaer.DAVIS_CONFIG_MUX_RUN_CHIP,
                                  enable)

    @property
    def davis_mux_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_MUX,
                                     libcaer.DAVIS_CONFIG_MUX_RUN)

    @davis_mux_enabled.setter
    def davis_mux_enabled(self, enable: bool):
        if not self.davis_mux_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_MUX,
                                  libcaer.DAVIS_CONFIG_MUX_RUN,
                                  enable)

    @property
    def davis_mux_timestamp_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_MUX,
                                     libcaer.DAVIS_CONFIG_MUX_TIMESTAMP_RUN)

    @davis_mux_timestamp_enabled.setter
    def davis_mux_timestamp_enabled(self, enable: bool):
        if not self.davis_mux_timestamp_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_MUX,
                                  libcaer.DAVIS_CONFIG_MUX_TIMESTAMP_RUN,
                                  enable)

    @property
    def dvs_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_DVS,
                                     libcaer.DAVIS_CONFIG_DVS_RUN)

    @dvs_enabled.setter
    def dvs_enabled(self, enable: bool):
        if not self.dvs_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_DVS,
                                  libcaer.DAVIS_CONFIG_DVS_RUN,
                                  enable)

    @property
    def imu_enabled(self) -> bool:
        acc = self.davis.get_config(libcaer.DAVIS_CONFIG_IMU,
                                    libcaer.DAVIS_CONFIG_IMU_RUN_ACCELEROMETER)
        gyr = self.davis.get_config(libcaer.DAVIS_CONFIG_IMU,
                                    libcaer.DAVIS_CONFIG_IMU_RUN_GYROSCOPE)
        tmp = self.davis.get_config(libcaer.DAVIS_CONFIG_IMU,
                                    libcaer.DAVIS_CONFIG_IMU_RUN_TEMPERATURE)
        return all([acc, gyr, tmp])

    @imu_enabled.setter
    def imu_enabled(self, enable: bool):
        if not self.imu_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_IMU,
                                  libcaer.DAVIS_CONFIG_IMU_RUN_ACCELEROMETER,
                                  enable)
            self.davis.set_config(libcaer.DAVIS_CONFIG_IMU,
                                  libcaer.DAVIS_CONFIG_IMU_RUN_GYROSCOPE,
                                  enable)
            self.davis.set_config(libcaer.DAVIS_CONFIG_IMU,
                                  libcaer.DAVIS_CONFIG_IMU_RUN_TEMPERATURE,
                                  enable)

    @property
    def aps_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_APS,
                                     libcaer.DAVIS_CONFIG_APS_RUN)

    @aps_enabled.setter
    def aps_enabled(self, enable: bool):
        if not self.aps_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_APS,
                                  libcaer.DAVIS_CONFIG_APS_RUN,
                                  enable)

    @property
    def extinput_generator_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_APS,
                                     libcaer.DAVIS_CONFIG_APS_SNAPSHOT)

    @extinput_generator_enabled.setter
    def extinput_generator_enabled(self, enable: bool):
        if not self.extinput_generator_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_EXTINPUT,
                                  libcaer.DAVIS_CONFIG_EXTINPUT_RUN_GENERATOR,
                                  enable)

    @property
    def extinput_detector_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_APS,
                                     libcaer.DAVIS_CONFIG_APS_SNAPSHOT)

    @extinput_detector_enabled.setter
    def extinput_detector_enabled(self, enable: bool):
        if not self.extinput_detector_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_EXTINPUT,
                                  libcaer.DAVIS_CONFIG_EXTINPUT_RUN_DETECTOR,
                                  enable)

    @property
    def snapshot_enabled(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_APS,
                                     libcaer.DAVIS_CONFIG_APS_SNAPSHOT)

    @snapshot_enabled.setter
    def snapshot_enabled(self, enable: bool):
        if not self.snapshot_enabled:
            self.davis.set_config(libcaer.DAVIS_CONFIG_APS,
                                  libcaer.DAVIS_CONFIG_APS_SNAPSHOT,
                                  enable)

    @property
    def aps_autoexposure(self) -> bool:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_APS,
                                     libcaer.DAVIS_CONFIG_APS_AUTOEXPOSURE)

    @aps_autoexposure.setter
    def aps_autoexposure(self, enable: bool):
        if not self.aps_autoexposure:
            self.davis.set_config(libcaer.DAVIS_CONFIG_APS,
                                  libcaer.DAVIS_CONFIG_APS_AUTOEXPOSURE,
                                  enable)

    @property
    def aps_exposure_time(self) -> int:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_APS,
                                     libcaer.DAVIS_CONFIG_APS_AUTOEXPOSURE)

    @aps_exposure_time.setter
    def aps_exposure_time(self, value: int):
        self.davis.set_config(libcaer.DAVIS_CONFIG_APS,
                              libcaer.DAVIS_CONFIG_APS_EXPOSURE,
                              value)

    @property
    def aps_frame_interval(self) -> int:
        return self.davis.get_config(libcaer.DAVIS_CONFIG_APS,
                                     libcaer.DAVIS_CONFIG_APS_FRAME_INTERVAL)

    @aps_frame_interval.setter
    def aps_frame_interval(self, value: int):
        self.davis.set_config(libcaer.DAVIS_CONFIG_APS,
                              libcaer.DAVIS_CONFIG_APS_FRAME_INTERVAL,
                              value)

    @property
    def davis_bias(self) -> dict:
        return self.davis.get_bias()

    @davis_bias.setter
    def davis_bias(self, biases: dict = None):
        if biases:
            self.davis.set_bias(biases)
            self._default_bias = False

    def davis_roi_filter(self, roi: [[int, int], [int, int]] = None):
        if roi is not None:
            start, end = roi  # [[int, int], [int, int]] = [top-left[x,y], bottom-right[x,y]]
            if self.davis.dvs_has_ROI_filter:
                self.davis.set_config(libcaer.DAVIS_CONFIG_DVS,
                                      libcaer.DAVIS_CONFIG_DVS_FILTER_ROI_START_COLUMN,
                                      start[0])
                self.davis.set_config(libcaer.DAVIS_CONFIG_DVS,
                                      libcaer.DAVIS_CONFIG_DVS_FILTER_ROI_START_ROW,
                                      start[1])
                self.davis.set_config(libcaer.DAVIS_CONFIG_DVS,
                                      libcaer.DAVIS_CONFIG_DVS_FILTER_ROI_END_COLUMN,
                                      end[0])
                self.davis.set_config(libcaer.DAVIS_CONFIG_DVS,
                                      libcaer.DAVIS_CONFIG_DVS_FILTER_ROI_END_ROW,
                                      end[1])
                self._roi = roi
            else:
                self._roi = None

    def davis_communication_configuration(self, max_packet_interval: float = 10, max_packet_size: int = 5000):
        # --> Host(usb)-side (receiver)
        self.davis.set_config(libcaer.CAER_HOST_CONFIG_USB,
                              libcaer.CAER_HOST_CONFIG_USB_BUFFER_NUMBER,
                              8)
        self.davis.set_config(libcaer.CAER_HOST_CONFIG_USB,
                              libcaer.CAER_HOST_CONFIG_USB_BUFFER_SIZE,
                              8192)  # or 4096
        self.davis.set_config(libcaer.DAVIS_CONFIG_USB,
                              libcaer.DAVIS_CONFIG_USB_EARLY_PACKET_DELAY,
                              8)

        # --> Device-side (transmitter)
        self.davis.set_config(libcaer.CAER_HOST_CONFIG_DATAEXCHANGE,
                              libcaer.CAER_HOST_CONFIG_DATAEXCHANGE_BUFFER_SIZE,
                              64)
        self.davis.set_config(libcaer.CAER_HOST_CONFIG_PACKETS,
                              libcaer.CAER_HOST_CONFIG_PACKETS_MAX_CONTAINER_PACKET_SIZE,
                              max_packet_size)
        self.davis.set_config(libcaer.CAER_HOST_CONFIG_PACKETS,
                              libcaer.CAER_HOST_CONFIG_PACKETS_MAX_CONTAINER_INTERVAL,
                              int(max_packet_interval * 1e3))  # set it high not to produce too many packets/second

    def davis_data_exchange_configuration(self, start_all_modules: bool = False, wait_valid_event: bool = True):
        self.davis.set_config(libcaer.CAER_HOST_CONFIG_DATAEXCHANGE,
                              libcaer.CAER_HOST_CONFIG_DATAEXCHANGE_START_PRODUCERS,
                              start_all_modules)
        self.davis.set_config(libcaer.CAER_HOST_CONFIG_DATAEXCHANGE,
                              libcaer.CAER_HOST_CONFIG_DATAEXCHANGE_BLOCKING,
                              wait_valid_event)

    def _davis_start_data(self):
        self.davis.data_start()
        self.davis_enabled = True  # enables only essential device modules: USB, CHIP, MUX, MUX_timestamp
        if self.reset_timestamps:
            self.davis.set_config(libcaer.DAVIS_CONFIG_MUX,
                                  libcaer.DAVIS_CONFIG_MUX_TIMESTAMP_RESET,
                                  True)

    def _davis_stop_data(self):
        self.davis.data_stop()  # disables all device modules: USB, CHIP, MUX, MUX_timestamp, DVS, APS and IMU

    # def davis_keep_running(self):
    #     # Enable external AER control, keep chip running
    #     self.davis_chip_enabled = True
    #     self.dvs_enabled = False
    #     self.davis.set_config(libcaer.DAVIS_CONFIG_DVS,
    #                           libcaer.DAVIS_CONFIG_DVS_EXTERNAL_AER_CONTROL,
    #                           True)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close_davis()

    def __del__(self):
        self.close_davis()

    def close(self):
        if self.verbose:
            print("\nClosing device....")
        self.close_davis()
        if self.verbose:
            print("Device was successfully closed.")

    def close_davis(self):
        if not self.__davis_closed:
            self.davis.close()
            self.__davis_closed = True

    def print_info(self):

        print('\n----------------------------------- Recording info ------------------------------------')
        what2rec = {'aps': 'only APS', 'aps&imu': 'both APS and IMU',
                    'dvs': 'only DVS', 'dvs&imu': 'both DVS and IMU',
                    'all': 'all APS, DVS and IMU'}.get(self._what2rec)
        print("\nThe neuromorphic sensor found is a {} with serial number {}, pixel-array size\n"
              "of {}x{}, {} biases, {} ROI filter, SW noise filter {} and {} HW background-activity filter.\n"
              "The recording will last for {} ms, and {} info will be recorded.\n"
              .format(' '.join(self.davis.device_string.split()[0:2]), self.davis.device_serial_number,
                      self.davis.dvs_size_X, self.davis.dvs_size_Y,
                      {True: 'default', False: 'customized'}.get(self._default_bias),
                      ('no' if self._roi is None else f'{self._roi[1][0]-self._roi[0][0]}x{self._roi[1][1]-self._roi[0][1]}'),
                      {True: 'enabled', False: 'disabled'}.get(self.davis.filter_noise),
                      {True: 'custom', False: 'no'}.get(self.davis.dvs_has_background_activity_filter),
                      int(self._duration_rec), what2rec
                      ))

    def record_info(self):
        # Define general full path, with no extension, of files to save
        if self.rec_file is None:
            self.rec_file = "./" + datetime.now().strftime("%d%b%Y_%H:%M:%S")  # no file extension
        file = os.path.splitext(self.rec_file)[0]  # no file extension

        # Define files to save
        info_file = file + '.json'
        aps_file = file + '_aps.avi'
        dvs_file = file + '_dvs' + self.file_extension
        imu_file = file + '_imu' + self.file_extension
        err_file = None

        # Save .json file with all information on recording (files saved and movement used)
        rec_struct = {
            'aps': {'aps': aps_file, 'dvs': None, 'imu': None, 'err': err_file},
            'aps&imu': {'aps': aps_file, 'dvs': None, 'imu': imu_file, 'err': err_file},
            'dvs': {'aps': None, 'dvs': dvs_file, 'imu': None, 'err': err_file},
            'dvs&imu': {'aps': None, 'dvs': dvs_file, 'imu': imu_file, 'err': err_file},
            'all': {'aps': aps_file, 'dvs': dvs_file, 'imu': imu_file, 'err': err_file}}.get(self._what2rec)
        info_struct = {'rec': rec_struct,
                       'fem': None,
                       'img': None}
        store_json(file=info_file,
                   info=info_struct)

        return info_file, info_struct

    def delete_existing_recording(self):
        if self.rec_file is not None and os.path.isfile(self.rec_file):
            # Load .json file with all information on recording (files saved and movement used)
            info_file = os.path.splitext(self.rec_file)[0] + '.json'
            info_struct = read_json(info_file)
            for rec_type in ['aps', 'dvs', 'imu', 'err']:
                old_file = info_struct['rec'][rec_type]
                if old_file is not None and os.path.isfile(old_file):
                    os.remove(old_file)
            os.remove(info_file)

    def check_temperature(self, duration: float = 0.1e6) -> float or None:
        """
        This function returns the median temperature of the device as detected from some IMU data collected (but not
        stored to disk) during a given time period (in us, default is 1 second) of recording.
        """

        # Initialize variables
        tot_num_imu_events = 0
        first_imu = 0
        imu_pack = np.zeros((1, 8))
        temperatures = []

        # Start data stream
        self._davis_start_data()
        # Enable only the device components you need: IMU
        self.imu_enabled = True

        # Loop through the events received from the sensor
        while True:
            try:
                packet_container, packet_number = self.davis.get_packet_container()
                if packet_container is not None:
                    for packet_id in range(packet_number):
                        packet_header, packet_type = self.davis.get_packet_header(packet_container, packet_id)
                        if packet_type == libcaer.IMU6_EVENT:
                            imu_pack, n_imu_pack = self.davis.get_imu6_event(
                                packet_header
                            )
                            temperatures.append(imu_pack[:, -1])
                            if tot_num_imu_events == 0 and n_imu_pack > 0:
                                first_imu = imu_pack[0, 0]
                            tot_num_imu_events += n_imu_pack
                        else:
                            pass
                    libcaer.caerEventPacketContainerFree(packet_container)
                    if (imu_pack[-1, 0] - first_imu) >= duration:
                        break
                else:
                    pass

            except KeyboardInterrupt:
                self.davis.shutdown()
                break

        # Stop data stream
        self._davis_stop_data()

        # Compute and return median temperature value
        try:
            temperature = float(np.nanmedian(np.hstack(temperatures)))
            return temperature if temperature else None
        except ValueError:
            return None

    def shot_aps(self):
        """
        This function takes an APS snapshot (single frame, as a photo-camera) and returns it as a uint8 grayscale array.
        """

        # Grub the current APS configurations
        frame_interval = self.aps_frame_interval
        autoexposure = self.aps_autoexposure
        exposure_time = self.aps_exposure_time

        # It is better to set the frame interval to 0 before taking the snapshot (for quick readiness of the APS)
        self.aps_frame_interval = 0
        # Also set the auto-exposure flag to True to make sure a decent exposure time is considered
        self.aps_autoexposure = True

        # Start data stream
        self._davis_start_data()
        # Enable only the device components you need: APS snapshot
        self.snapshot_enabled = True

        # Take the snapshot
        frame = None
        t0 = time.time()
        while frame is None:

            if (time.time() - t0) > 2:  # Wait no longer than 2 seconds for a frame to be passed from the sensor
                break

            try:
                packet_container, packet_number = self.davis.get_packet_container()
                if packet_container is not None:
                    for packet_id in range(packet_number):
                        packet_header, packet_type = self.davis.get_packet_header(packet_container, packet_id)
                        if packet_type == libcaer.FRAME_EVENT:
                            frame, frame_ts = self.davis.get_frame_event(
                                packet_header, device_type=self.davis.chip_id,
                                aps_filter_type=self.davis.aps_color_filter
                            )
                        else:
                            pass
                    libcaer.caerEventPacketContainerFree(packet_container)
                else:
                    pass

            except KeyboardInterrupt:
                self.davis.shutdown()
                break

        # Stop data stream
        self._davis_stop_data()

        # Re-set the previous APS configurations
        self.aps_frame_interval = frame_interval
        self.aps_autoexposure = autoexposure
        self.aps_exposure_time = exposure_time

        return frame

    def record_aps(self, apsfile: str):
        """
        This function creates 1 txt file with all recorded APS frames.
        The APS file is a .avi recording consisting of a set of standard grayscale frames.
        """

        # Open recording files
        videocap = cv2.VideoWriter(apsfile, cv2.VideoWriter_fourcc(*'PIM1'), 20,
                                   (self.davis.dvs_size_X, self.davis.dvs_size_Y), False)
        apsfile_ts = os.path.splitext(apsfile)[0] + 'ts' + self.file_extension
        txt_aps = open(apsfile_ts, 'w+')
        txt_aps.write(f"# APS frames from {' '.join(self.davis.device_string.split()[:-1])} "
                      f'with shape [w h] = {self.davis.dvs_size_X} {self.davis.dvs_size_Y}\n')
        txt_aps.write("# All the N frames, corresponding to the N timestamps stored here, are stored in a .avi file.\n")

        # Initialize variables
        duration = self._duration_rec * 1e3
        tot_num_aps_frames = 0
        first_aps = 0
        frame_ts = 0

        # Start data stream
        self._davis_start_data()
        # Enable only the device components you need: APS
        self.aps_enabled = True

        # Keep track of the time at which data stream begins
        print('\nB) Data stream is starting!')
        t_start = datetime.now().timestamp()

        # Loop through the events received from the sensor
        while True:
            if self._exit_event.is_set():
                break
            try:
                packet_container, packet_number = self.davis.get_packet_container()
                if packet_container is not None:
                    for packet_id in range(packet_number):
                        packet_header, packet_type = self.davis.get_packet_header(packet_container, packet_id)
                        if packet_type == libcaer.FRAME_EVENT:
                            frame_mat, frame_ts = self.davis.get_frame_event(
                                packet_header, device_type=self.davis.chip_id,
                                aps_filter_type=self.davis.aps_color_filter
                            )
                            txt_aps.write(f'{frame_ts}\n')
                            videocap.write(frame_mat)
                            if tot_num_aps_frames == 0:
                                first_aps = frame_ts
                            tot_num_aps_frames += 1
                        else:
                            pass
                    libcaer.caerEventPacketContainerFree(packet_container)
                    if (frame_ts - first_aps) >= duration:
                        break
                else:
                    pass

            except KeyboardInterrupt:
                self.davis.shutdown()
                break

        # Keep track of the time at which data stream ends
        t_stop = datetime.now().timestamp()

        # Stop data stream
        self._davis_stop_data()

        # Send start and stop timestamps to the queue
        self._queue.put(('rec', t_start, t_stop))

        # Compute APS recording duration
        aps_dur = (frame_ts - int(first_aps)) * 1e-6

        # Close recording files
        txt_aps.close()

        print(f'\nE) Data has been logged to file!\n'
              f'   - Duration of APS recording: {round(aps_dur, 6)} seconds\n'
              f'   - Number of APS frames: {tot_num_aps_frames}\n'
              f'   - Frame rate of APS device: {int(tot_num_aps_frames / aps_dur) if aps_dur > 0 else "..."} Hz'
              )

    def record_apsimu(self, apsfile: str, imufile: str):
        """
        This function creates 3 different txt files with all recorded DVS, APS and IMU events.
        - The IMU file uses the first 2 lines as header to store some basic info on device and data format in the file.
          It then stores 8 info on every newline (each event) with the following format:
             timestamp (int,us), X acceleration (float,ms/s), Y acc. (float,ms/s), Z acc. (float,ms/s),
             X angular velocity (float,°/s), Y ang. vel. (float,°/s), Z ang. vel. (float,°/s), temperature (float,°C)
        - The APS file is a .avi recording consisting of a set of standard grayscale frames.
        """

        # Open recording files
        txt_imu = open(imufile, 'w+')
        txt_imu.write(f"# IMU events from  {' '.join(self.davis.device_string.split()[:-1])} \n")
        txt_imu.write('# Events are in the form: [t x-acc y-acc z-acc x-gyr y-gyr z-gyr temp]\n')
        videocap = cv2.VideoWriter(apsfile, cv2.VideoWriter_fourcc(*'PIM1'), 20,
                                   (self.davis.dvs_size_X, self.davis.dvs_size_Y), False)
        apsfile_ts = os.path.splitext(apsfile)[0] + 'ts' + self.file_extension
        txt_aps = open(apsfile_ts, 'w+')
        txt_aps.write(f"# APS frames from {' '.join(self.davis.device_string.split()[:-1])} "
                      f'with shape [w h] = {self.davis.dvs_size_X} {self.davis.dvs_size_Y}\n')
        txt_aps.write("# All the N frames, corresponding to the N timestamps stored here, are stored in a .avi file.\n")

        # Initialize variables
        duration = self._duration_rec * 1e3
        tot_num_imu_events = 0
        tot_num_aps_frames = 0
        first_aps = 0
        frame_ts = 0
        imu_pack = np.zeros((1, 8))

        # Start data stream
        self._davis_start_data()
        # Enable only the device components you need: APS and IMU
        self.aps_enabled = True
        self.imu_enabled = True

        # Keep track of the time at which data stream begins
        print('\nB) Data stream is starting!')
        t_start = datetime.now().timestamp()

        # Loop through the events received from the sensor
        while True:
            if self._exit_event.is_set():
                break
            try:
                packet_container, packet_number = self.davis.get_packet_container()
                if packet_container is not None:
                    for packet_id in range(packet_number):
                        packet_header, packet_type = self.davis.get_packet_header(packet_container, packet_id)
                        if packet_type == libcaer.FRAME_EVENT:
                            frame_mat, frame_ts = self.davis.get_frame_event(
                                packet_header, device_type=self.davis.chip_id,
                                aps_filter_type=self.davis.aps_color_filter
                            )
                            txt_aps.write(f'{frame_ts}\n')
                            videocap.write(frame_mat)
                            if tot_num_aps_frames == 0:
                                first_aps = frame_ts
                            tot_num_aps_frames += 1
                        elif packet_type == libcaer.IMU6_EVENT:
                            imu_pack, n_imu_pack = self.davis.get_imu6_event(
                                packet_header
                            )
                            np.savetxt(txt_imu, imu_pack, fmt='%i %.6f %.6f %.6f %.6f %.6f %.6f %.6f', newline="\n")
                            tot_num_imu_events += n_imu_pack
                        else:
                            pass
                    libcaer.caerEventPacketContainerFree(packet_container)
                    if (frame_ts - first_aps) >= duration:
                        break
                else:
                    pass

            except KeyboardInterrupt:
                self.davis.shutdown()
                break

        # Keep track of the time at which data stream ends
        t_stop = datetime.now().timestamp()

        # Stop data stream
        self._davis_stop_data()

        # Send start and stop timestamps to the queue
        self._queue.put(('rec', t_start, t_stop))

        # Compute APS recording duration
        aps_dur = (frame_ts - int(first_aps)) * 1e-6
        # Compute IMU recording duration
        txt_imu.seek(0)
        for _ in range(2):
            txt_imu.readline()
        first_imu = txt_imu.readline().split(' ')[0]
        imu_dur = (imu_pack[-1, 0] - int(first_imu)) * 1e-6

        # Close recording files
        txt_imu.close()
        txt_aps.close()

        print(f'\nE) Data has been logged to file!\n'
              f'   - Duration of APS recording: {round(aps_dur, 6)} seconds\n'
              f'   - Number of APS frames: {tot_num_aps_frames}\n'
              f'   - Frame rate of APS device: {int(tot_num_aps_frames / aps_dur) if aps_dur > 0 else "..."} Hz\n'
              f'   - Duration of IMU recording: {round(imu_dur, 6)} seconds\n'
              f'   - Number of IMU events: {tot_num_imu_events}\n'
              f'   - Sampling rate of IMU device: {int(tot_num_imu_events / imu_dur) if imu_dur > 0 else "..."} Hz\n'
              f'   - Device temperature: {round(float(imu_pack[-1, -1]), 2)} °C'
              )

    def record_dvs(self, dvsfile: str):
        """
        This function creates 3 different txt files with all recorded DVS, APS and IMU events.
        - The DVS file uses the first 2 lines as header to store some basic info on device and data format in the file,
          plus the pixel array shape (w, h). 4 info are then stored on every newline (event) with the following format:
             timestamp (int, us), x coordinate (int), y coordinate (int), polarity (int, 0/1)
        """

        # Open recording files
        txt_dvs = open(dvsfile, 'w+')
        txt_dvs.write(f"# DVS events from {' '.join(self.davis.device_string.split()[:-1])} "
                      f'with shape [w h] = {self.davis.dvs_size_X} {self.davis.dvs_size_Y}\n')
        txt_dvs.write('# Events are in the form: [t x y p]\n')
        format_dvs_data = '%i %i %i %i %i' if self._noise_filter else '%i %i %i %i'

        # Initialize variables
        duration = self._duration_rec * 1e3
        tot_num_dvs_events = 0
        first_dvs = 0
        dvs_pack = np.zeros((1, 4))

        # Start data stream
        self._davis_start_data()
        # Enable only the device components you need: DVS
        self.dvs_enabled = True

        # Start data stream
        print('\nB) Data stream is starting!')
        t_start = datetime.now().timestamp()

        # Loop through the events received from the sensor
        while True:
            if self._exit_event.is_set():
                break
            try:
                packet_container, packet_number = self.davis.get_packet_container()
                if packet_container is not None:
                    for packet_id in range(packet_number):
                        packet_header, packet_type = self.davis.get_packet_header(packet_container, packet_id)
                        if packet_type == libcaer.POLARITY_EVENT:
                            dvs_pack, n_dvs_pack = self.davis.get_polarity_event(
                                packet_header, self._noise_filter
                            )
                            if self._noise_filter:
                                dvs_pack = dvs_pack[dvs_pack[:, 4] == 1][:, :-1]
                                n_dvs_pack = dvs_pack.shape[0]
                            np.savetxt(txt_dvs, dvs_pack, fmt=format_dvs_data, newline="\n")
                            if tot_num_dvs_events == 0 and n_dvs_pack > 0:
                                first_dvs = dvs_pack[0, 0]
                            tot_num_dvs_events += n_dvs_pack
                        else:
                            pass
                    libcaer.caerEventPacketContainerFree(packet_container)
                    if (dvs_pack[-1, 0] - first_dvs) >= duration:
                        break
                else:
                    pass

            except KeyboardInterrupt:
                self.davis.shutdown()
                break

        # Keep track of the time at which data stream ends
        t_stop = datetime.now().timestamp()

        # Stop data stream
        self._davis_stop_data()

        # Send start and stop timestamps to the queue
        self._queue.put(('rec', t_start, t_stop))

        # Compute DVS recording duration
        dvs_dur = (dvs_pack[-1, 0] - int(first_dvs)) * 1e-6

        # Close recording files
        txt_dvs.close()

        print(f'\nE) Data has been logged to file!\n'
              f'   - Duration of DVS recording: {round(dvs_dur, 6)} seconds\n'
              f'   - Number of DVS events: {tot_num_dvs_events}\n'
              )

    def record_dvsimu(self, dvsfile: str, imufile: str):
        """
        This function creates 2 different txt files with all recorded DVS and IMU events. New events are stored in new
        lines while different info of a same event are separated with a blank space.
        - The DVS file uses the first 2 lines as header to store some basic info on device and data format in the file,
          plus the pixel array shape (w, h). 4 info are then stored on every newline (event) with the following format:
             timestamp (int, us), x coordinate (int), y coordinate (int), polarity (int, 0/1)
        - The IMU file uses the first 2 lines as header to store some basic info on device and data format in the file.
          It then stores 8 info for each event with the following format:
             timestamp (int,us), X acceleration (float,ms/s), Y acc. (float,ms/s), Z acc. (float,ms/s),
             X angular velocity (float,°/s), Y ang. vel. (float,°/s), Z ang. vel. (float,°/s), temperature (float,°C)
        """

        # Open recording files
        txt_imu = open(imufile, 'w+')
        txt_imu.write(f"# IMU events from {' '.join(self.davis.device_string.split()[:-1])}\n")
        txt_imu.write('# Events are in the form: [t x-acc y-acc z-acc x-gyr y-gyr z-gyr temp]\n')
        txt_dvs = open(dvsfile, 'w+')
        txt_dvs.write(f"# DVS events from {' '.join(self.davis.device_string.split()[:-1])} "
                      f'with shape [w h] = {self.davis.dvs_size_X} {self.davis.dvs_size_Y}\n')
        txt_dvs.write('# Events are in the form: [t x y p]\n')
        format_dvs_data = '%i %i %i %i %i' if self._noise_filter else '%i %i %i %i'

        # Initialize variables
        duration = self._duration_rec * 1e3
        tot_num_dvs_events = 0
        tot_num_imu_events = 0
        first_dvs = 0
        dvs_pack = np.zeros((1, 4))
        imu_pack = np.zeros((1, 8))

        # Start data stream
        self._davis_start_data()
        # Enable only the device components you need: DVS and IMU
        self.dvs_enabled = True
        self.imu_enabled = True

        # Keep track of the time at which data stream begins
        print('\nB) Data stream is starting!')
        t_start = datetime.now().timestamp()

        # Loop through the events received from the sensor
        while True:
            if self._exit_event.is_set():
                break
            try:
                packet_container, packet_number = self.davis.get_packet_container()
                if packet_container is not None:
                    for packet_id in range(packet_number):
                        packet_header, packet_type = self.davis.get_packet_header(packet_container, packet_id)
                        if packet_type == libcaer.POLARITY_EVENT:
                            dvs_pack, n_dvs_pack = self.davis.get_polarity_event(packet_header, self._noise_filter)
                            if self._noise_filter:
                                dvs_pack = dvs_pack[dvs_pack[:, 4] == 1][:, :-1]
                                n_dvs_pack = dvs_pack.shape[0]
                            np.savetxt(txt_dvs, dvs_pack, fmt=format_dvs_data, newline="\n")
                            if tot_num_dvs_events == 0 and n_dvs_pack > 0:
                                first_dvs = dvs_pack[0, 0]
                            tot_num_dvs_events += n_dvs_pack
                        elif packet_type == libcaer.IMU6_EVENT:
                            imu_pack, n_imu_pack = self.davis.get_imu6_event(packet_header)
                            np.savetxt(txt_imu, imu_pack, fmt='%i %.6f %.6f %.6f %.6f %.6f %.6f %.6f', newline="\n")
                            tot_num_imu_events += n_imu_pack
                        else:
                            pass
                    libcaer.caerEventPacketContainerFree(packet_container)
                    if (dvs_pack[-1, 0] - first_dvs) >= duration:
                        break
                else:
                    pass

            except KeyboardInterrupt:
                self.davis.shutdown()
                break

        # Keep track of the time at which data stream ends
        t_stop = datetime.now().timestamp()

        # Stop data stream
        self._davis_stop_data()

        # Send start and stop timestamps to the queue
        self._queue.put(('rec', t_start, t_stop))

        # Compute DVS recording duration
        dvs_dur = (dvs_pack[-1, 0] - int(first_dvs)) * 1e-6
        # Compute IMU recording duration
        txt_imu.seek(0)
        for _ in range(2):
            txt_imu.readline()
        first_imu = txt_imu.readline().split(' ')[0]
        imu_dur = (imu_pack[-1, 0] - int(first_imu)) * 1e-6

        # Close recording files
        txt_dvs.close()
        txt_imu.close()

        print(f'\nE) Data has been logged to file!\n'
              f'   - Duration of DVS recording: {round(dvs_dur, 6)} seconds\n'
              f'   - Number of DVS events: {tot_num_dvs_events}\n'
              f'   - Duration of IMU recording: {round(imu_dur, 6)} seconds\n'
              f'   - Number of IMU events: {tot_num_imu_events}\n'
              f'   - Sampling rate of IMU device: {int(tot_num_imu_events / imu_dur) if imu_dur > 0 else "..."} Hz\n'
              f'   - Device temperature: {round(float(imu_pack[-1, -1]), 2)} °C'
              )

    def record_all(self, apsfile: str, dvsfile: str, imufile: str):
        """
        This function creates 3 different txt files with all recorded DVS, APS and IMU events.
        - The DVS file uses the first 2 lines as header to store some basic info on device and data format in the file,
          plus the pixel array shape (w, h). 4 info are then stored on every newline (event) with the following format:
             timestamp (int, us), x coordinate (int), y coordinate (int), polarity (int, 0/1)
        - The IMU file uses the first 2 lines as header to store some basic info on device and data format in the file.
          It then stores 8 info on every newline (each event) with the following format:
             timestamp (int,us), X acceleration (float,ms/s), Y acc. (float,ms/s), Z acc. (float,ms/s),
             X angular velocity (float,°/s), Y ang. vel. (float,°/s), Z ang. vel. (float,°/s), temperature (float,°C)
        - The APS file is a .avi recording consisting of a set of standard grayscale frames.
        """

        # Open recording files
        videocap = cv2.VideoWriter(apsfile, cv2.VideoWriter_fourcc(*'PIM1'), 20,
                                   (self.davis.dvs_size_X, self.davis.dvs_size_Y), False)
        apsfile_ts = os.path.splitext(apsfile)[0] + 'ts' + self.file_extension
        txt_aps = open(apsfile_ts, 'w+')
        txt_aps.write(f"# APS frames from {' '.join(self.davis.device_string.split()[:-1])} "
                      f'with shape [w h] = {self.davis.dvs_size_X} {self.davis.dvs_size_Y}\n')
        txt_aps.write("# All the N frames, corresponding to the N timestamps stored here, are stored in a .avi file.\n")
        txt_imu = open(imufile, 'w+')
        txt_imu.write(f"# IMU events from {' '.join(self.davis.device_string.split()[:-1])}\n")
        txt_imu.write('# Events are in the form: [t x-acc y-acc z-acc x-gyr y-gyr z-gyr temp]\n')
        txt_dvs = open(dvsfile, 'w+')
        txt_dvs.write(f"# DVS events from {' '.join(self.davis.device_string.split()[:-1])} "
                      f'with shape [w h] = {self.davis.dvs_size_X} {self.davis.dvs_size_Y}\n')
        txt_dvs.write('# Events are in the form: [t x y p]\n')
        format_dvs_data = '%i %i %i %i %i' if self._noise_filter else '%i %i %i %i'

        # Initialize variables
        duration = self._duration_rec * 1e3
        tot_num_dvs_events = 0
        tot_num_imu_events = 0
        tot_num_aps_frames = 0
        first_dvs = 0
        frame_ts = 0
        dvs_pack = np.zeros((1, 4))
        imu_pack = np.zeros((1, 8))

        # Start data stream
        self._davis_start_data()
        # Enable only the device components you need: APS, DVS and IMU
        self.aps_enabled = True
        self.dvs_enabled = True
        self.imu_enabled = True

        # Keep track of the time at which data stream begins
        print('\nB) Data stream is starting!')
        t_start = datetime.now().timestamp()

        # Loop through the events received from the sensor
        while True:
            if self._exit_event.is_set():
                break
            try:
                packet_container, packet_number = self.davis.get_packet_container()
                if packet_container is not None:
                    for packet_id in range(packet_number):
                        packet_header, packet_type = self.davis.get_packet_header(packet_container, packet_id)
                        if packet_type == libcaer.POLARITY_EVENT:
                            dvs_pack, n_dvs_pack = self.davis.get_polarity_event(
                                packet_header, self._noise_filter
                            )
                            if self._noise_filter:
                                dvs_pack = dvs_pack[dvs_pack[:, 4] == 1][:, :-1]
                                n_dvs_pack = dvs_pack.shape[0]
                            np.savetxt(txt_dvs, dvs_pack, fmt=format_dvs_data, newline="\n")
                            if tot_num_dvs_events == 0 and n_dvs_pack > 0:
                                first_dvs = dvs_pack[0, 0]
                            tot_num_dvs_events += n_dvs_pack
                        elif packet_type == libcaer.IMU6_EVENT:
                            imu_pack, n_imu_pack = self.davis.get_imu6_event(
                                packet_header
                            )
                            np.savetxt(txt_imu, imu_pack, fmt='%i %.6f %.6f %.6f %.6f %.6f %.6f %.6f', newline="\n")
                            tot_num_imu_events += n_imu_pack
                        elif packet_type == libcaer.FRAME_EVENT:
                            frame_mat, frame_ts = self.davis.get_frame_event(
                                packet_header, device_type=self.davis.chip_id,
                                aps_filter_type=self.davis.aps_color_filter
                            )
                            txt_aps.write(f'{frame_ts}\n')
                            videocap.write(frame_mat)
                            tot_num_aps_frames += 1
                        else:
                            pass
                    libcaer.caerEventPacketContainerFree(packet_container)
                    if (dvs_pack[-1, 0] - first_dvs) >= duration:
                        break
                else:
                    pass

            except KeyboardInterrupt:
                self.davis.shutdown()
                break

        # Keep track of the time at which data stream ends
        t_stop = datetime.now().timestamp()

        # Stop data stream
        self._davis_stop_data()

        # Send start and stop timestamps to the queue
        self._queue.put(('rec', t_start, t_stop))

        # Compute DVS recording duration
        dvs_dur = (dvs_pack[-1, 0] - int(first_dvs)) * 1e-6
        # Compute IMU recording duration
        txt_imu.seek(0)
        for _ in range(2):
            txt_imu.readline()
        first_imu = txt_imu.readline().split(' ')[0]
        imu_dur = (imu_pack[-1, 0] - int(first_imu)) * 1e-6
        # Compute APS recording duration
        txt_aps.seek(0)
        for _ in range(2):
            txt_aps.readline()
        first_aps = txt_aps.readline()
        aps_dur = (frame_ts - int(first_aps)) * 1e-6

        # Close recording files
        txt_dvs.close()
        txt_imu.close()
        txt_aps.close()

        print(f'\nE) Data has been logged to file!\n'
              f'   - Duration of APS recording: {round(aps_dur, 6)} seconds\n'
              f'   - Number of APS frames: {tot_num_aps_frames}\n'
              f'   - Frame rate of APS device: {int(tot_num_aps_frames / aps_dur) if aps_dur > 0 else "..."} Hz\n'
              f'   - Duration of DVS recording: {round(dvs_dur, 6)} seconds\n'
              f'   - Number of DVS events: {tot_num_dvs_events}\n'
              f'   - Duration of IMU recording: {round(imu_dur, 6)} seconds\n'
              f'   - Number of IMU events: {tot_num_imu_events}\n'
              f'   - Sampling rate of IMU device: {int(tot_num_imu_events / imu_dur) if imu_dur > 0 else "..."} Hz\n'
              f'   - Device temperature: {round(float(imu_pack[-1, -1]), 2)} °C'
              )

    def _record_timeout_issue(self, info_file):
        # Define a general error file
        err_file = os.path.splitext(info_file)[0] + '_err' + self.file_extension

        # Store info of timeout issues in the recording thread
        leave_space = '\n\n' if os.path.isfile(err_file) else ''  # leave some space in the text if file already exists
        with open(err_file, 'a+') as txt_err:
            text = '======================================== Timeout issue ========================================\n' \
                   f' -- The recording has been interrupted since the relative thread has been alive for more than ' \
                   f'{round(self._timeout_rec * 1e-3, 2)} seconds\n' \
                   f' -- while the recording should have last {round(self._duration_rec * 1e-3, 2)} seconds\n' \
                   f' -- Check the actual duration of the recorded events, it is probably shorter than the target ' \
                   f'duration!\n' \
                   f' -- This could have been caused by a too large amount of DVS events generated by the sensor,\n' \
                   f' -- which slowed down their transmission and storage. Check the raster-plot of the DVS events,\n' \
                   f' -- if this was the case it should be very dense, and possibly with some holes in time (due to\n' \
                   f' -- some packets of events thrown away).'
            txt_err.write(leave_space + text)

        # Update file where info of recording are stored
        update_json(file=info_file,
                    new_entries={'rec': {'err': err_file}})

    def _record_order_issue(self, info_file):
        # Define a general error file
        err_file = os.path.splitext(info_file)[0] + '_err' + self.file_extension

        # Store info of order issues between different parallel processes
        leave_space = '\n\n' if os.path.isfile(err_file) else ''  # leave some space in the text if file already exists
        with open(err_file, 'a+') as txt_err:
            text = '========================================= Order issue =========================================\n'
            for key, val in zip(self._order.keys(), self._order.values()):
                text += f' -- {key}: started at {datetime.fromtimestamp(val[0]).strftime("%H:%M:%S:%f")} ' \
                        f'and ended at {datetime.fromtimestamp(val[1]).strftime("%H:%M:%S:%f")}\n'
            txt_err.write(leave_space + text)

        # Update file where info of recording are stored
        update_json(file=info_file,
                    new_entries={'rec': {'err': err_file}})

    def retrieve_queue_info(self):
        self._order = dict()
        while not self._queue.empty():
            msg = self._queue.get(block=False)
            self._order[msg[0]] = (msg[1], msg[2])

    @property
    def threads_order(self) -> dict:
        if not self._queue.empty():
            self.retrieve_queue_info()
        return self._order

    def run(self):

        # Delete pre-existing recordings with same name (rec_file)
        self.delete_existing_recording()

        # Define full paths of files to save
        info_file, info_struct = self.record_info()

        # Create DAVIS recording thread
        rec_func = {'aps': self.record_aps, 'aps&imu': self.record_apsimu,
                    'dvs': self.record_dvs, 'dvs&imu': self.record_dvsimu,
                    'all': self.record_all}.get(self._what2rec)
        rec_args = tuple([v for v in info_struct['rec'].values() if v is not None])
        self._exit_event.clear()
        thread_record = Thread(target=rec_func, args=rec_args)

        # +++ Start recording
        time.sleep(self._delay_rec * 1e-3)  # wait some time before recording data
        thread_record.start()

        # +++ Make sure the DAVIS recording thread has finished (record a timeout issue otherwise)
        thread_record.join(self._timeout_rec * 1e-3)
        if thread_record.is_alive():
            self._exit_event.set()
            print('Recording has been interrupted.', file=stderr)
            self._record_timeout_issue(info_file)
        thread_record.join()

        # Retrieve info from the queue (just to empty it)
        self.retrieve_queue_info()


class RecordSceneFEM(RecordScene):
    """
    Class for live-recording (on a .txt file) the data generated by a neuromorphic camera (DAVIS sensor) while it is
    moving thanks to a pan-tilt unit (PTU device). The recording is run as a thread in parallel to the PTU movement.
    All time parameters (such as dur_record or max_packet_interval) are considered to have millisecond units.
    # Note: Streaming data from the pyaer DAVIS object through a second process of the multiprocessing package seems
    # to be not supported, therefore a Thread was used for recording data while a Process for moving the pan-tilt unit.
    Usage:
    myexp = RecordSceneFEM(set_all_experiment_parameters)
    {loop:
        myexp.run()
    }
    myexp.close()
    """

    def __init__(self,
                 verbose: bool = True,
                 # 1) Recording info
                 rec_file: str = None, file_extension: str = '.csv', what2rec: str = 'all',
                 duration_rec: float = 1000, timeout_rec: float = 5000, delay_rec: float = 0,
                 config_file: str = None, noise_filter: bool = False, roi: [[int, int], [int, int]] = None,
                 start_all_modules: bool = False, wait_valid_event: bool = True,
                 max_packet_interval: float = 10, max_packet_size: int = 5000,
                 reset_timestamps: bool = True,
                 # 2) Movement info
                 fem_file: str = None, fem_seed: int = None, fem: np.ndarray = None,
                 delay_fem: float = None, timeout_fem: float = 6000, baud: int = 19200,
                 steps: (str, str) = ('E', 'E'), hold_power: (str, str) = ('low', 'low'),
                 speed_bounds: (int, int, int) = (0, 140, 180), speed: int = 150, acc: int = 200,
                 ):

        self.__ptu_closed = False

        # --------------------------------------------------------------------------------------------------------------
        # --> 1) Recording info
        super().__init__(
            verbose=False,
            rec_file=rec_file, file_extension=file_extension, what2rec=what2rec,
            duration_rec=duration_rec, timeout_rec=timeout_rec, delay_rec=delay_rec,
            max_packet_interval=max_packet_interval, max_packet_size=max_packet_size,
            start_all_modules=start_all_modules, wait_valid_event=wait_valid_event,
            noise_filter=noise_filter, roi=roi, config_file=config_file,
            reset_timestamps=reset_timestamps,
        )

        # --------------------------------------------------------------------------------------------------------------
        # --> 2) Movement info
        self._fem = fem.tolist() if fem is not None else None
        self.fem_file = fem_file
        self.fem_seed = fem_seed
        self._delay_fem = delay_fem if delay_fem is not None \
            else 0.25 * self._duration_rec  # (ms) burn-in period of the movement:
        # i.e. time period after recording starts and before PTU begins to move (rec_start - fem_start)
        if not (self._duration_rec > self._delay_fem):
            # Note: cannot check that duration_rec > duration_fem + delay_fem because duration of FEM depends on the
            #       particular FEM sequence given and speed/acceleration of the PTU (should check this every time
            #       the FEM sequence is changed)
            raise ValueError('Duration mismatches! Must be:  duration_rec > delay_fem')

        # ### Initialize the PTU object
        self.__init_ptu(baud=baud, timeout=timeout_fem, hold_power=hold_power, steps=steps,
                        acc=acc, speed=speed, speed_bounds=speed_bounds)

        # --------------------------------------------------------------------------------------------------------------
        # ### Print info of experiment
        if verbose:
            self.print_info()

    def __init_ptu(self, baud: int, timeout: float,
                   hold_power: (str, str), steps: (str, str),
                   acc: int, speed: int, speed_bounds: (int, int, int)):
        self.ptu = PTU(port=find_ptuport(verbose=False), baud=baud, timeout=timeout*1e-3, steps=steps, verbose=False)
        # Set power modes
        self.ptu.hold_power = hold_power
        # Set acceleration, target speed and speed boundaries
        self.ptu.accelerations = (deg2pos(self.ptu.pan_resolution, acc),
                                  deg2pos(self.ptu.tilt_resolution, acc))
        self.ptu.speed_bounds = (tuple(deg2pos(self.ptu.pan_resolution, val) for val in speed_bounds),
                                 tuple(deg2pos(self.ptu.tilt_resolution, val) for val in speed_bounds))
        self.ptu.target_speeds = (deg2pos(self.ptu.pan_resolution, speed),
                                  deg2pos(self.ptu.tilt_resolution, speed))
        # Save value in internal variables
        self.__speeds = self.ptu.target_speeds
        self.__accs = self.ptu.accelerations
        # Make sure the PTU starts in the origin
        self.ptu_to_origin()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close_devices()

    def __del__(self):
        self.close_devices()

    def close(self):
        if self.verbose:
            print("\nClosing all devices....")
        self.close_devices()
        if self.verbose:
            print("Devices were successfully closed.")

    def close_ptu(self):
        if not self.__ptu_closed:
            self.ptu.hold_power = ('off', 'off')
            self.ptu.close()
            self.__ptu_closed = True

    def close_devices(self):
        self.close_davis()
        self.close_ptu()

    def print_info(self):
        super(RecordSceneFEM, self).print_info()

        print('\n------------------------------------ Movement info ------------------------------------')
        print("\nThe pan-tilt unit found is a PTU-{} with serial number {} and controller version {}\n"
              "from {} {} "
              .format(self.ptu.device_model, self.ptu.device_serial_number, self.ptu.device_version.split()[2][1:-1],
                      ' '.join(self.ptu.device_version.split()[4: 7])[:-1], self.ptu.device_version.split()[3]), end='')
        possiblesteps = {'F': 'full', 'H': 'half', 'Q': 'quarter', 'E': 'eighth', 'A': 'automatic'}
        print("Echo is {}, execution mode is {},\n"
              "speed-control mode is {},\n"
              "step resolutions are P:{}, T:{}, i.e. P:{}'', T:{}'',\n"
              "min and max position limits are P:{}°, T:{}°,\n"
              "min, base and max speeds are P:{}°/sec, T:{}°/sec,\n"
              "target speeds are P:{}°/sec, T:{}°/sec, and accelerations P:{}°/sec\u00b2, T:{}°/sec\u00b2.\n"
              .format('enabled' if self.ptu.echo else 'disabled',
                      'slaved' if self.ptu.execution == 'S' else 'immediate',
                      'independent (i.e. speed and position are independently controlled)'
                      if self.ptu.control_mode == 'pos' else 'pure velocity (i.e. speed affects position)',
                      possiblesteps.get(self.ptu.steps[0]), possiblesteps.get(self.ptu.steps[1]),
                      self.ptu.pan_resolution, self.ptu.tilt_resolution,
                      tuple(round(pos2deg(self.ptu.pan_resolution, val), 3) for val in self.ptu.pan_position_limits),
                      tuple(round(pos2deg(self.ptu.tilt_resolution, val), 3) for val in self.ptu.tilt_position_limits),
                      tuple(round(pos2deg(self.ptu.pan_resolution, val), 3) for val in self.ptu.pan_speed_bounds),
                      tuple(round(pos2deg(self.ptu.tilt_resolution, val), 3) for val in self.ptu.tilt_speed_bounds),
                      round(pos2deg(self.ptu.pan_resolution, self.__speeds[0]), 3),
                      round(pos2deg(self.ptu.tilt_resolution, self.__speeds[1]), 3),
                      round(pos2deg(self.ptu.pan_resolution, self.__accs[0]), 3),
                      round(pos2deg(self.ptu.tilt_resolution, self.__accs[1]), 3)
                      ))

    def record_info(self):
        info_file, info_struct = super(RecordSceneFEM, self).record_info()

        # Update file where info of recording are stored
        update_json(file=info_file,
                    new_entries={'fem': {'file': self.fem_file,
                                         'seed': self.fem_seed}})

        return info_file, info_struct

    def check_threads_order(self) -> bool:
        if not self._queue.empty():
            self.retrieve_queue_info()
        try:
            rec_start, rec_stop = self._order['rec']
            fem_start, fem_stop = self._order['fem']
        except KeyError:
            return False
        right_order = ((rec_start < fem_start) &
                       (fem_stop < rec_stop))
        return right_order

    @property
    def fem(self) -> list or None:
        return self._fem

    @fem.setter
    def fem(self, fem: np.ndarray):
        self._fem = fem.tolist()

    def ptu_to_origin(self):
        if any(self.ptu.positions):
            self.ptu.positions = (0, 0)

    def move_ptu(self, fem: list):
        """Drive the PTU to reproduce a given FEM motion sequence."""

        # Keep track of the time when the movement begins
        t_start = datetime.now().timestamp()
        print("\nC) The PTU is starting to move!")

        # Send motion-sequence commands to the pan-tilt unit
        duration = self.ptu.setTrajectory(fem, return_response=False)

        # Keep track of the time when the movement ends
        t_stop = datetime.now().timestamp()
        finalpos = tuple(np.array(fem).sum(axis=0))
        if self.ptu.positions == finalpos:
            text = "The final position of the trajectory was successfully reached after %.3f seconds." % duration
        else:
            text = "The final position of the trajectory was NOT reached after %.3f seconds: " \
                   "it is %s but it should be %s." % (duration, self.ptu.positions, finalpos)
        print('\nD) ' + text)

        # Send start and stop timestamps to the queue
        self._queue.put(('fem', t_start, t_stop))

    def run(self):

        # Delete pre-existing recordings with same name (rec_file)
        self.delete_existing_recording()

        # Define full paths of files to save
        info_file, info_struct = self.record_info()

        # Update movement sequence
        fem = self._fem
        assert isinstance(fem, list), 'No motion was loaded!!'

        # Create DAVIS recording thread
        rec_func = {'aps': self.record_aps, 'aps&imu': self.record_apsimu,
                    'dvs': self.record_dvs, 'dvs&imu': self.record_dvsimu,
                    'all': self.record_all}.get(self._what2rec)
        rec_args = tuple([v for v in info_struct['rec'].values() if v is not None])
        self._exit_event.clear()
        thread_record = Thread(target=rec_func, args=rec_args)

        # Create PTU movement process
        thread_motion = Process(target=self.move_ptu, args=(fem,))

        # +++ Start recording
        time.sleep(self._delay_rec * 1e-3)  # wait some time before recording data
        thread_record.start()

        # >>> Start moving PTU
        time.sleep(self._delay_fem * 1e-3)  # give some time to start recording data before starting the movement
        thread_motion.start()

        # >>> Make sure the PTU movement process has finished
        thread_motion.join()

        # +++ Make sure the DAVIS recording thread has finished (record a timeout issue otherwise)
        thread_record.join(self._timeout_rec * 1e-3)
        if thread_record.is_alive():
            self._exit_event.set()
            print('Recording has been interrupted.', file=stderr)
            self._record_timeout_issue(info_file)
        thread_record.join()

        # Reset PTU to the origin
        self.ptu_to_origin()

        # Check whether the different processes were executed in the correct order
        right_order = self.check_threads_order()
        if not right_order:
            print('The processes were not executed in the correct order.', file=stderr)
            self._record_order_issue(info_file)


class RecordImage(RecordScene):
    """
    Class for displaying a static image on a second monitor and live-recording (on a .txt file) the data generated by
    a neuromorphic camera (DAVIS sensor).
    The recording, which is run as a thread in parallel to the stimulation, will start immediately after the stimulation
    begins and should end before.
    All time parameters (such as dur_record or max_packet_interval) are considered to have millisecond units.
    # Note: Streaming data from the pyaer DAVIS object through a second process of the multiprocessing package seems
    # to be not supported, therefore a Thread was used for recording data.
    Usage:
    myexp = RecordImage(set_all_experiment_parameters)
    {loop:
        myexp.img_file = file
        myexp.run()
    }
    myexp.close()
    """

    def __init__(self,
                 verbose: bool = True,
                 # 1) Recording info
                 rec_file: str = None, file_extension: str = '.csv', what2rec: str = 'all',
                 duration_rec: float = 1000, timeout_rec: float = 5000, delay_rec: float = 0,
                 config_file: str = None, noise_filter: bool = False, roi: [[int, int], [int, int]] = None,
                 start_all_modules: bool = False, wait_valid_event: bool = True,
                 max_packet_interval: float = 10, max_packet_size: int = 5000,
                 reset_timestamps: bool = True,
                 # 2) Stimulus info
                 img_file: str = None, img: np.ndarray = None, img_transforms: list = None,
                 img_id: int = None, img_label: int = None, img_split: str = None, img_dataset: str = None,
                 duration_img: float = None, timeout_img: float = None,
                 second_monitor: bool = False, monitor_resolution: (int, int) = None,
                 border_img: float = None, border_img_color: (int, int, int) or str = 'infer',
                 ):

        # --------------------------------------------------------------------------------------------------------------
        super().__init__(
            verbose=False,
            # --> 1) Recording info
            rec_file=rec_file, file_extension=file_extension, what2rec=what2rec,
            duration_rec=duration_rec, timeout_rec=timeout_rec, delay_rec=delay_rec,
            max_packet_interval=max_packet_interval, max_packet_size=max_packet_size,
            start_all_modules=start_all_modules, wait_valid_event=wait_valid_event,
            noise_filter=noise_filter, roi=roi, config_file=config_file,
            reset_timestamps=reset_timestamps,
        )

        # --------------------------------------------------------------------------------------------------------------
        # 2) --> Stimulus info
        self._duration_img = duration_img if duration_img is not None \
            else 2 * self._duration_rec  # (ms) duration of stimulation
        self._delay_rec = delay_rec if delay_rec is not None \
            else 0.2 * self._duration_img  # (ms) burn-in period of the recording:
        # i.e. time period after stimulation starts and before recording begins (img_start - rec_start)
        if not (self._duration_img > (self._duration_rec + self._delay_rec)):
            raise ValueError('Duration mismatches! Must be:  duration_img > duration_rec + delay_rec')
        self._timeout_img = timeout_img if timeout_img is not None \
            else 1.3 * self._duration_img  # (ms) time period to wait for stimulation process to end
        if not self._timeout_img > self._duration_img:
            raise ValueError('Timeout for stimulation interruption must be greater than stimulation duration.')
        self._second_monitor = second_monitor  # whether to use a second monitor connected to the PC or the built-in one
        self._builtin_monitor_resolution, _ = get_multi_screen_geometry()  # (width, height)
        self._monitor_resolution = monitor_resolution if self._second_monitor \
            else self._builtin_monitor_resolution  # (width, height) of the monitor where the image should be displayed
        if self._monitor_resolution is None:
            raise ValueError('Must specify the resolution of the monitor where the image should be displayed!')
        self.border_img = border_img  # % of the monitor that should be occupied by a white border surrounding the image
        self.border_img_color = border_img_color  # the color of such border. If it is "infer" it will be adapted to img
        self._img = self._adapt_img2screen(img) if img is not None else None
        self.img_id = img_id
        self.img_file = img_file
        self.img_label = img_label
        self.img_split = img_split
        self.img_dataset = img_dataset
        self.img_transforms = img_transforms

        # --------------------------------------------------------------------------------------------------------------
        # ### Print info of experiment
        if verbose:
            self.print_info()

    def print_info(self):
        super(RecordImage, self).print_info()

        print('\n----------------------------------- Stimulation info ----------------------------------')
        print("\nThe stimulation will be on the {} monitor, having a resolution of {}.\n"
              "The static image will be displayed for {} ms.\n"
              .format('second' if self._second_monitor else 'built-in', self._monitor_resolution,
                      int(self._duration_img)
                      ))

    def record_info(self):
        info_file, info_struct = super(RecordImage, self).record_info()

        # Update file where info of recording are stored
        update_json(file=info_file,
                    new_entries={'img': {'file': self.img_file,
                                         'index': self.img_id,
                                         'label': self.img_label,
                                         'split': self.img_split,
                                         'dataset': self.img_dataset,
                                         'transform': ', '.join(self.img_transforms) if self.img_transforms else None}})

        return info_file, info_struct

    def _record_timeout_stimulus_issue(self, info_file):
        # Define a general error file
        err_file = os.path.splitext(info_file)[0] + '_err' + self.file_extension

        # Store info of timeout issues in the stimulation thread
        leave_space = '\n\n' if os.path.isfile(err_file) else ''  # leave some space in the text if file already exists
        with open(err_file, 'a+') as txt_err:
            text = '======================================== Timeout issue ========================================\n' \
                   f' -- The stimulation has been interrupted since the relative process has been alive for more than' \
                   f' {round(self._timeout_img * 1e-3, 2)} seconds\n' \
                   f' -- while the stimulation should have last {round(self._duration_img * 1e-3, 2)} seconds\n' \
                   f' -- Check the recorded events, there could have been some issues with the image displayed\n' \
                   f' -- on the monitor (maybe the image never appeared on the screen)!\n'
            txt_err.write(leave_space + text)

        # Update file where info of recording are stored
        update_json(file=info_file,
                    new_entries={'rec': {'err': err_file}})

    def check_threads_order(self) -> bool:
        if not self._queue.empty():
            self.retrieve_queue_info()
        try:
            rec_start, rec_stop = self._order['rec']
            img_start, img_stop = self._order['img']
        except KeyError:
            return False
        right_order = ((img_start < rec_start) &
                       (rec_stop < img_stop))
        return right_order

    @property
    def img(self) -> np.ndarray or None:
        return self._img

    @img.setter
    def img(self, img: np.ndarray):
        self._img = self._adapt_img2screen(self._transform_img(img))

    def _transform_img(self, img: np.ndarray) -> np.ndarray:
        image = preprocess_image(img, transforms=self.img_transforms)
        return image

    def _adapt_img2screen(self, img: np.ndarray) -> np.ndarray:
        image = adapt_img2screen(img, border_img=self.border_img, border_color=self.border_img_color,
                                 monitor_resolution=self._monitor_resolution)
        return image

    def show_img(self, img: np.ndarray):
        """This function displays an image on the monitor for a given amount of time."""

        # Create the window where the image will be displayed in full screen
        cv2.namedWindow("image", cv2.WINDOW_KEEPRATIO)
        if self._second_monitor:
            cv2.moveWindow("image", *self._builtin_monitor_resolution)
        cv2.setWindowProperty("image", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

        # Keep track of the time when the stimulation begins
        t_start = datetime.now().timestamp()
        print("\nA) Stimulation is starting!")

        # Display the image
        cv2.imshow("image", img)

        # Display it for some time, then stop and destroy the window
        cv2.waitKey(int(self._duration_img))
        cv2.destroyAllWindows()

        # Keep track of the time when the stimulation ends
        t_stop = datetime.now().timestamp()
        print(f"\nF) Stimulation ended! "
              f"Total duration of the stimulation is {int(round((t_stop - t_start) * 10 ** 3))} ms.")

        # Send start and stop timestamps to the queue
        self._queue.put(('img', t_start, t_stop))

    def run(self):

        # Delete pre-existing recordings with same name (rec_file)
        self.delete_existing_recording()

        # Define full paths of files to save
        info_file, info_struct = self.record_info()

        # Update stimulus
        img = self._img
        assert isinstance(img, np.ndarray), 'No image was loaded!!'

        # Create stimulus process
        thread_img = Process(target=self.show_img, args=(img,))

        # Create DAVIS recording thread
        rec_func = {'aps': self.record_aps, 'aps&imu': self.record_apsimu,
                    'dvs': self.record_dvs, 'dvs&imu': self.record_dvsimu,
                    'all': self.record_all}.get(self._what2rec)
        rec_args = tuple([v for v in info_struct['rec'].values() if v is not None])
        self._exit_event.clear()
        thread_record = Thread(target=rec_func, args=rec_args)

        # ***** Start the stimulation
        thread_img.start()

        # +++ Start recording
        time.sleep(self._delay_rec * 1e-3)  # give some time to display the image before recording data
        thread_record.start()

        # +++ Make sure the DAVIS recording thread has finished (record a timeout issue otherwise)
        thread_record.join(self._timeout_rec * 1e-3)
        if thread_record.is_alive():
            self._exit_event.set()
            print('Recording has been interrupted.', file=stderr)
            self._record_timeout_issue(info_file)
        thread_record.join()

        # *** Make sure the stimulation process has finished
        thread_img.join(self._timeout_img * 1e-3)
        if thread_img.is_alive():
            thread_img.terminate()
            print('Stimulation has been interrupted.', file=stderr)
            self._record_timeout_stimulus_issue(info_file)

        # Check whether the different processes were executed in the correct order
        right_order = self.check_threads_order()
        if not right_order:
            print('The processes were not executed in the correct order.', file=stderr)
            self._record_order_issue(info_file)


class RecordImageFEM(RecordSceneFEM):
    """
    Class for displaying a static image on a second monitor and live-recording (on a .txt file) the data generated by
    a neuromorphic camera (DAVIS sensor) that meanwhile is moving thanks to a pan-tilt unit (PTU device).
    The recording, which is run as a thread in parallel to the stimulation and to the PTU movement, will start
    immediately after the stimulation begins and should end before.
    All time parameters (such as dur_record or max_packet_interval) are considered to have millisecond units.
    # Note: Streaming data from the pyaer DAVIS object through a second process of the multiprocessing package seems
    # to be not supported, therefore a Thread was used for recording data while a Process for moving the pan-tilt unit.
    Usage:
    myexp = RecordImageFEM(set_all_experiment_parameters)
    {loop:
        myexp.img_file = file
        myexp.run()
    }
    myexp.close()
    """

    def __init__(self,
                 verbose: bool = True,
                 # 1) Recording info
                 rec_file: str = None, file_extension: str = '.csv', what2rec: str = 'all',
                 duration_rec: float = 1000, timeout_rec: float = 5000, delay_rec: float = 0,
                 config_file: str = None, noise_filter: bool = False, roi: [[int, int], [int, int]] = None,
                 start_all_modules: bool = False, wait_valid_event: bool = True,
                 max_packet_interval: float = 10, max_packet_size: int = 5000,
                 reset_timestamps: bool = True,
                 # 2) Movement info
                 fem_file: str = None, fem_seed: int = None,
                 delay_fem: float = None, timeout_fem: float = 6000, baud: int = 19200,
                 steps: (str, str) = ('E', 'E'), hold_power: (str, str) = ('low', 'low'),
                 speed_bounds: (int, int, int) = (0, 140, 180), speed: int = 150, acc: int = 200,
                 # 3) Stimulus info
                 img_file: str = None, img: np.ndarray = None, img_transforms: list = None,
                 img_id: int = None, img_label: int or str = None, img_split: str = None, img_dataset: str = None,
                 duration_img: float = None, timeout_img: float = None,
                 second_monitor: bool = False, monitor_resolution: (int, int) = None,
                 border_img: float = None, border_img_color: (int, int, int) or str = 'infer'
                 ):

        # --------------------------------------------------------------------------------------------------------------
        super().__init__(
            verbose=False,
            # --> 1) Recording info
            rec_file=rec_file, file_extension=file_extension, what2rec=what2rec,
            duration_rec=duration_rec, timeout_rec=timeout_rec, delay_rec=delay_rec,
            max_packet_interval=max_packet_interval, max_packet_size=max_packet_size,
            start_all_modules=start_all_modules, wait_valid_event=wait_valid_event,
            noise_filter=noise_filter, roi=roi, config_file=config_file,
            reset_timestamps=reset_timestamps,
            # --> 2) Movement info
            fem_file=fem_file, fem_seed=fem_seed,
            delay_fem=delay_fem, timeout_fem=timeout_fem, baud=baud,
            steps=steps, hold_power=hold_power, speed_bounds=speed_bounds, speed=speed, acc=acc
        )

        # --------------------------------------------------------------------------------------------------------------
        # 3) --> Stimulus info
        self._duration_img = duration_img if duration_img is not None \
            else 2 * duration_rec  # (ms) duration of stimulation
        self._delay_rec = delay_rec if delay_rec is not None \
            else 0.2 * self._duration_img  # (ms) burn-in period of the recording:
        # i.e. time period after stimulation starts and before recording begins (img_start - rec_start)
        if not (self._duration_img > (self._duration_rec + self._delay_rec)):
            raise ValueError('Duration mismatches! Must be:  duration_img > duration_rec + delay_rec')
        self._timeout_img = timeout_img if timeout_img is not None \
            else 1.3 * self._duration_img  # (ms) time period to wait for stimulation process to end
        if not self._timeout_img > self._duration_img:
            raise ValueError('Timeout for stimulation interruption must be greater than stimulation duration.')
        self._second_monitor = second_monitor  # whether to use a second monitor connected to the PC or the built-in one
        self._builtin_monitor_resolution, _ = get_multi_screen_geometry()  # (width, height)
        self._monitor_resolution = monitor_resolution if self._second_monitor \
            else self._builtin_monitor_resolution  # (width, height) of the monitor where the image should be displayed
        if self._monitor_resolution is None:
            raise ValueError('Must specify the resolution of the monitor where the image should be displayed!')
        self.border_img = border_img  # % of the monitor that should be occupied by a white border surrounding the image
        self.border_img_color = border_img_color  # the color of such border. If it is "infer" it will be adapted to img
        self._img = self._adapt_img2screen(img) if img is not None else None
        self.img_id = img_id
        self.img_file = img_file
        self.img_label = img_label
        self.img_split = img_split
        self.img_dataset = img_dataset
        self.img_transforms = img_transforms

        # --------------------------------------------------------------------------------------------------------------
        # ### Print info of experiment
        if verbose:
            self.print_info()

    def print_info(self):
        super(RecordImageFEM, self).print_info()

        print('\n----------------------------------- Stimulation info ----------------------------------')
        print("\nThe stimulation will be on the {} monitor, having a resolution of {}.\n"
              "The static image will be displayed for {} ms.\n"
              .format('second' if self._second_monitor else 'built-in', self._monitor_resolution,
                      int(self._duration_img)
                      ))

    def record_info(self):
        info_file, info_struct = super(RecordSceneFEM, self).record_info()

        # Update file where info of recording are stored
        update_json(file=info_file,
                    new_entries={'fem': {'file': self.fem_file,
                                         'seed': self.fem_seed},
                                 'img': {'file': self.img_file,
                                         'index': self.img_id,
                                         'label': self.img_label,
                                         'split': self.img_split,
                                         'dataset': self.img_dataset,
                                         'transform': ', '.join(self.img_transforms) if self.img_transforms else None}})

        return info_file, info_struct

    def _record_timeout_stimulus_issue(self, info_file):
        # Define a general error file
        err_file = os.path.splitext(info_file)[0] + '_err' + self.file_extension

        # Store info of timeout issues in the stimulation thread
        leave_space = '\n\n' if os.path.isfile(err_file) else ''  # leave some space in the text if file already exists
        with open(err_file, 'a+') as txt_err:
            text = '======================================== Timeout issue ========================================\n' \
                   f' -- The stimulation has been interrupted since the relative process has been alive for more than' \
                   f' {round(self._timeout_img * 1e-3, 2)} seconds\n' \
                   f' -- while the stimulation should have last {round(self._duration_img * 1e-3, 2)} seconds\n' \
                   f' -- Check the recorded events, there could have been some issues with the image displayed\n' \
                   f' -- on the monitor (maybe the image never appeared on the screen)!\n'
            txt_err.write(leave_space + text)

        # Update file where info of recording are stored
        update_json(file=info_file,
                    new_entries={'rec': {'err': err_file}})

    def check_threads_order(self) -> bool:
        if not self._queue.empty():
            self.retrieve_queue_info()
        try:
            rec_start, rec_stop = self._order['rec']
            fem_start, fem_stop = self._order['fem']
            img_start, img_stop = self._order['img']
        except KeyError:
            return False
        right_order = ((img_start < rec_start < fem_start) &
                       (fem_stop < rec_stop < img_stop))
        return right_order

    @property
    def img(self) -> np.ndarray or None:
        return self._img

    @img.setter
    def img(self, img: np.ndarray):
        self._img = self._adapt_img2screen(self._transform_img(img))

    def _transform_img(self, img: np.ndarray) -> np.ndarray:
        image = preprocess_image(img, transforms=self.img_transforms)
        return image

    def _adapt_img2screen(self, img: np.ndarray) -> np.ndarray:
        image = adapt_img2screen(img, border_img=self.border_img, border_color=self.border_img_color,
                                 monitor_resolution=self._monitor_resolution)
        return image

    def show_img(self, img: np.ndarray):
        """This function displays an image on the monitor for a given amount of time."""

        # Create the window where the image will be displayed in full screen
        cv2.namedWindow("image", cv2.WINDOW_KEEPRATIO)
        if self._second_monitor:
            cv2.moveWindow("image", *self._builtin_monitor_resolution)
        cv2.setWindowProperty("image", cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)

        # Keep track of the time when the stimulation begins
        t_start = datetime.now().timestamp()
        print("\nA) Stimulation is starting!")

        # Display the image
        cv2.imshow("image", img)

        # Display it for some time, then stop and destroy the window
        cv2.waitKey(int(self._duration_img))
        cv2.destroyAllWindows()

        # Keep track of the time when the stimulation ends
        t_stop = datetime.now().timestamp()
        print(f"\nF) Stimulation ended! "
              f"Total duration of the stimulation is {int(round((t_stop - t_start) * 10 ** 3))} ms.")

        # Send start and stop timestamps to the queue
        self._queue.put(('img', t_start, t_stop))

    def run(self):
        """NOTE: before calling this method you should update "img" and all other img-related attributes."""

        # Delete pre-existing recordings with same name (rec_file)
        self.delete_existing_recording()

        # Define full paths of files to save
        info_file, info_struct = self.record_info()

        # Update stimulus and movement sequence
        fem = self._fem
        assert isinstance(fem, list), 'No motion was loaded!!'
        img = self._img
        assert isinstance(img, np.ndarray), 'No image was loaded!!'

        # Create stimulus process
        thread_img = Process(target=self.show_img, args=(img,))

        # Create PTU movement process
        thread_motion = Process(target=self.move_ptu, args=(fem,))

        # Create DAVIS recording thread
        rec_func = {'aps': self.record_aps, 'aps&imu': self.record_apsimu,
                    'dvs': self.record_dvs, 'dvs&imu': self.record_dvsimu,
                    'all': self.record_all}.get(self._what2rec)
        rec_args = tuple([v for v in info_struct['rec'].values() if v is not None])
        self._exit_event.clear()
        thread_record = Thread(target=rec_func, args=rec_args)

        # ***** Start the stimulation
        thread_img.start()

        # +++ Start recording
        time.sleep(self._delay_rec * 1e-3)  # give some time to display the image before recording data
        thread_record.start()

        # >>> Start moving PTU
        time.sleep(self._delay_fem * 1e-3)  # give some time to start recording data before starting the movement
        thread_motion.start()

        # >>> Make sure the PTU movement process has finished
        thread_motion.join()

        # +++ Make sure the DAVIS recording thread has finished (record a timeout issue otherwise)
        thread_record.join(self._timeout_rec * 1e-3)
        if thread_record.is_alive():
            self._exit_event.set()
            print('Recording has been interrupted.', file=stderr)
            self._record_timeout_issue(info_file)
        thread_record.join()

        # *** Make sure the stimulation process has finished
        thread_img.join(self._timeout_img * 1e-3)
        if thread_img.is_alive():
            thread_img.terminate()
            print('Stimulation has been interrupted.', file=stderr)
            self._record_timeout_stimulus_issue(info_file)

        # Check whether the different processes were executed in the correct order
        right_order = self.check_threads_order()
        if not right_order:
            print('The processes were not executed in the correct order.', file=stderr)
            self._record_order_issue(info_file)

        # Reset PTU to the origin
        self.ptu_to_origin()
